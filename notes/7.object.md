# Object

## 1. Properties

```js
const junha = { name: 'junha', age: 10 };
junha.hasJob = true;
```
-   오브젝트의 프로퍼티를 중간에 추가할 수 있다.
-   다른 언어에서는 흔치 않은 일이다.
-   유지보수가 힘드니까 한 번에 선언하는 것을 권장한다.

## 2. computed properties

- `computed properties`: `Object['key']`표기법
-   동적으로 key에 관한 value를 받아올 때 사용한다.
```js
function printValue(obj, key) {
    console.log(obj.key);   // undefined
}

function printValueComputed(obj, key) {
    console.log(obj[key]);  // junha
}

printValue(junha, 'name');
printValueComputed(junha, 'name');
```






## 3. Constructor Function

- 다른 계산을 하지 않고 순수하게 Object를 생성하는 함수는 대문자로 시작하는 이름으로 만든다.

```js
function Person(name, age) {
    //this = {}
    this.name = name;
    this.age = age;
    //return this
}
const yunjung = new Person('yunjung',21))
console.log(yunjung)  // Person {name: 'yunjung', age: 21}
```

## 4. `in` operator

-  해당 key가 object에 있는지 확인하는 연산자

```js
console.log('name' in junha); // true
console.log('random' in junha); // false
console.log(junha.random); // undeifined
```

## 5. `for in`, `for of`

```js
for (key in ellie) {
    console.log(key);
}

for (value of iterable) {
    console.log(value);
}
```

## 6. Cloning

```js
const user1 = { name: 'junha', age: 20 };
const user2 = user1;
user2.name = 'hajun';
```
-   user1, user2의 레퍼런스가 동일하기 때문에 user1의 name도 hajun으로 변한다.

**예시) Old way cloning**
```js
const user3 = {};
for (key in user) {
    userr3[key] = user[key];
}
```

**예시) `Object.assign`을 활용한 cloning**

-  `Object.assign(target, source)`
```js
const user4 = {};
Object.assign(user4, user);

const user4 = Object.assign({}, user);
```

```js
const fruit1 = { color: 'red', price: 'high' };
const fruit2 = { color: 'blue', size: 'big' };
const mixed = Object.assign({}, fruit1, fruit2);

console.log(mixed); // {color: 'blue', price: 'high', size: 'big'}
```
-   color 프로퍼티는 오버라이딩 된다.
