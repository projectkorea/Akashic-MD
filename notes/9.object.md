# Object

- 프로퍼티: 객체가 갖고 있는 **데이터**
- 메서드: 객체가 갖고 있는 **함수**

## 1. Properties

```js
const junha = { name: 'junha', age: 10 };
junha.hasJob = true;
```
-   오브젝트의 프로퍼티를 중간에 추가할 수 있다.
-   다른 언어에서는 흔치 않은 일이다.
-   유지보수가 힘드니까 한 번에 선언하는 것을 권장한다.

## 2. computed properties

- `computed properties`: `Object['key']`표기법
-   동적으로 key에 관한 value를 받아올 때 사용한다.
```js
function printValue(obj, key) {
    console.log(obj.key);   // undefined
}

function printValueComputed(obj, key) {
    console.log(obj[key]);  // junha
}

printValue(junha, 'name');
printValueComputed(junha, 'name');
```

## 3. function is `object` 

- 함수는 `object`이기 때문에 1) **함수를 변수에 할당**하거나 2) **함수 자체를 값으로써 리턴**할 수 있다.
```js
const func = function () {
  ...
}
function func2() {
  ...
  return function () {
    ...
  }
}
```
- 모든 함수는 `return undefiend`가 생략되어있다.


## 4. Constructor Function

- 다른 계산을 하지 않고 순수하게 Object를 생성하는 함수를 **생성자 함수**라 부르며, 대문자로 이름을 만든다.

```js
function Person(name, age) {
    //this = {}
    this.name = name;
    this.age = age;
    //return this
}
const yunjung = new Person('yunjung',21))
console.log(yunjung)  // Person {name: 'yunjung', age: 21}
```

## 5. `in` operator

-  해당 key가 object에 있는지 확인하는 연산자

```js
console.log('name' in junha); // true
console.log('random' in junha); // false
console.log(junha.random); // undeifined
```

## 6. `for in`, `for of`

```js
for (key in ellie) {
    console.log(key);
}

for (value of iterable) {
    console.log(value);
}
```

## 7. Cloning

```js
const user1 = { name: 'junha', age: 20 };
const user2 = user1;
user2.name = 'hajun';
```
-   user1, user2의 레퍼런스가 동일하기 때문에 user1의 name도 hajun으로 변한다.

**예시) Old way cloning**
```js
const user3 = {};
for (key in user) {
    userr3[key] = user[key];
}
```

**예시) `Object.assign`을 활용한 cloning**

-  `Object.assign(target, source)`
-  `target`에 `source`를 병합한 `target`을 리턴한다.
```js
const user1 = {name:'junha'};
const user2 = {age: 30}

const user3 = Object.assign(user1, user2);
const user4 = Object.assign({}, user1, user2);

user1 === user3 // true
user1 === user4 // false
```

```js
const fruit1 = { color: 'red', price: 'high' };
const fruit2 = { color: 'blue', size: 'big' };
const mixed = Object.assign({}, fruit1, fruit2);

console.log(mixed); // {color: 'blue', price: 'high', size: 'big'}
```
-   color 프로퍼티는 오버라이딩 된다.

## 8. examples

<details>
  <summary> 객체안에서의 메소드 (this 활용)</summary>

```js
const TwoDotDistance = {
  point1: {
    x: 0,
    y: 0,
  },

  point2: {
    x: 0,
    y: 0,
  },

  setPoints: function (x1, y1, x2, y2) {
    this.point1.x = x1;
    this.point1.y = y1;
    this.point2.x = x2;
    this.point2.y = y2;
  },

  calculateDistance: function () {
    const d = Math.sqrt(
      Math.pow(this.point1.x - this.point2.x, 2) +
        Math.pow(this.point1.y - this.point2.y, 2)
    );
    if (isNaN(d)) {
      return 0;
    } else {
      return d.toFixed(2);
    }
  },
};

export default TwoDotDistance;
```
</details>
