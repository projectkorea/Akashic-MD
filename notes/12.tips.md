# tips

## 0. Early return, Early exit(function)

- 조건이 맞지 않은 경우, 빨리 리턴하는 것을 말한다. 가독성 더 짱짱

**1) bad example**

```js
function upgradeUser(use) {
    if(user.point > 10){
        // heavy code...
    }
    else(){
        // ...
    }
}
```

**2) good example**

```js
function upgradeUser() {
    if(user.point <= 10){
        return;
    }
    // heavy logic...
}
```
---
## 1. use strict

-   Javascript is very flexible which is dangerous.

```js
'use strict';
a = 6; // not working with 'use strict'
```

## 2. Shorthand property names

- 객체를 생성할 때 만드려고하는 **`key`와 변수명이 같으면 `value`를 생략하고, key값으로만 프로퍼티를 설정할 수 있다.**

```js
const name = 'junha';
const age = '20';
const junha = { name, age };
// junha {name: name (='junha'), age: age(='20')}

function makePerson(name, age) {
    return {    
        name,  // name : name
        age,   // age : age
    };
}
console.log(makePerson('junha',10))
```

## 3. Destructuring assignment

- `const {prop1, prop2} = obj`

```js
const car = { name: 'Auid', age: '2022' };

const { name, age:birth } = car;  // destructuring...
// = const name = car.name;
// = const birth = car.age;
```

```js
const animals = ['dog', 'cat'];

const [first, second] = animals; / // destructuring...
// = const first = animals[0]
// = const second = animals[1]
```

## 4. Spread Syntax

- `...`을 붙여 프로퍼티들을 **펼친다**.

```js
const junha = {
    name: 'junha',
    age: '20',
    skill: 'js',
};

const junhaJunior1 = { ...junha}; 

const junhaJunior2 = { ...junha, skill: 'java' }; 
// spreadSyntax 도중 특정 프로퍼티의 값을 바꿀 수 있다.
```

```js
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const concatArr = [...arr1, ...arr2];
// 두 배열의 요소를 합쳐 하나의 배열로 만들 수 있다.

```

```js
function arrayAPI(array) {
  
  function push(element) {
    return [...array, element];
  }

  function removeElement(index) {
    return [...array.slice(0,index), ...array.slice(index+1)];
  }

  function updateElement(index, element) {
    return [...array.slice(0,index), element, ...array.slice(index+1)];
  }
```

## 5. Rest Parameter

-  `...`을 붙여 아규먼트들을 **배열**로 받아온다.

```js
function printAll(...args) {
    console.log(args);
}
printAll('kim', 'junha', 'jjang');
```

```js
function sumArray(sum, ...arr) {
    if (arr.length === 0) 
        return sum;
    const [head, ...tail] = arr;
    return sumArray(sum + head, ...tail);
}
sumArray(0, 1, 2, 3, 4, 5);
```

## 6. Default Parameter

```js
// Before
function print(msg) {
    if (msg === null) {
        msg = 'default msg';
    }
    console.log(msg);
}

// After
function print(msg = 'default msg') {
    console.log(msg);
}

print(); // default mag
print(0) // 0
```

-   Default parameter is only for `undefined`.
-   msg가 `undefined`인 경우에만 자동으로 할당된다.

---

## 1. Optional Chaining (ES11)

```js
const person1 = {
    name: 'junha',
    job: {
        title: 'Engineer',
        manager: {
            name: 'Bob',
        },
    },
};

const person2 = {
    name: 'yunjung',
};

function print(person) {
    console.log(person.job?.manager?.name);
}

print(person1); // bob
print(person2); // undefined
```

## 2. Nullish Coalescing Operator (ES11)

-   `??` 연산자: `null`과 `undefined` 일 경우에만 작동한다.
-   false: `false`, `''`, `0`, `null`, `undefined`

```js
{
    const obj = {
        0: false,     // false : false
        1: '',        // : 
        2: 0,         // 0: 0
        3: null,      // null : Nullish Coalescing
        4: undefined, // undefined : Nullish Coalescing
        5: NaN,       // NaN : NaN
    };

    for (let key in obj) {
        console.log(`${obj[key]}: ${obj[key] ?? 'Nullish Coalescing'}`);
    }
}
```

-   `leftExpr() ?? rightExpr()` 형태이기 때문에, `const result = func1() ?? func2()`도 가능하다.

## Quiz

-   Remove duplicates `['a','a','b','b','c','d','e']` and return as an array.

```js
const arr = ['a', 'a', 'b', 'b', 'c', 'd', 'e'];
const answer = [...new Set(arr)];
console.log(answer);
```