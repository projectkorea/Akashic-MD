# tips

## 0. Early return, Early exit(function)

- 조건이 맞지 않은 경우, 빨리 리턴하는 것을 말한다. 가독성 더 짱짱

#### bad example

```js
function upgradeUser(use) {
    if(user.point > 10){
        // heavy code...
    }
    else(){
        // ...
    }
}
```

#### good example

```js
function upgradeUser() {
    if(user.point <= 10){
        return;
    }
    // heavy logic...
}
```

## 1. use strict

-   Javascript is very flexible which is dangerous.

```js
'use strict';
a = 6; // not working with 'use strict'
```

## 2. Shorthand property names

- 객체를 생성할 때, `key`값과 동일한 변수명을 가진 변수를 할당할 경우, `value`를 생략할 수 있다.


```js
const name = 'junha';
const age = '20';

const junha = { name, age };
// const junha = {name: name, age: age}
```

```js
function makePerson(name, age) {
    return {    
        name,  // name : name
        age,   // age : age
    };
}
console.log(makePerson('junha',10))
```

## 3. Destructuring assignment

- `const {prop1, prop2} = obj`

```js
const car = { name: 'Auid', age: '2022' };

const { name, age:birth } = car;
// const name = car.name;
// const birth = car.age;
```

```js
const animals = ['dog', 'cat'];

const [first, second] = animals; 
// = const first = animals[0]
// = const second = animals[1]
```

### nested destructuring

```js
const obj1 = {
  title: "foo",
  child: {
    title2: "bar"
  },
};

const { title, child, child : { title2 }} = obj1
```

## 4. Spread Syntax

- `...`을 붙여 프로퍼티들을 **펼친다**

```js
const junha = {
    name: 'junha',
    age: '20',
    skill: 'js',
};

const junhaJunior1 = { ...junha}; 
const junhaJunior2 = { ...junha, skill: 'java' }; 
// spreadSyntax 도중 특정 프로퍼티의 값을 바꿀 수 있다.
```

```js
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const concatArr = [...arr1, ...arr2];
// 두 배열의 요소를 합쳐 하나의 배열로 만들 수 있다.

```

```js
function arrayAPI(array) {
  
  function push(element) {
    return [...array, element];
  }

  function removeElement(index) {
    return [...array.slice(0,index), ...array.slice(index+1)];
  }

  function updateElement(index, element) {
    return [...array.slice(0,index), element, ...array.slice(index+1)];
  }
```

## 5. Rest Parameter

-  `...`을 붙여 아규먼트들을 **배열**로 받아온다.

```js
function printAll(...args) {
    console.log(args);
}
printAll('kim', 'junha', 'jjang');
```

```js
function sumArray(sum, ...arr) {
    if (arr.length === 0) 
        return sum;
    const [head, ...tail] = arr;
    return sumArray(sum + head, ...tail);
}
sumArray(0, 1, 2, 3, 4, 5);
```

## 6. Default Parameter

#### Before
```js
function print(msg) {
    if (msg === null) {
        msg = 'default msg';
    }
    console.log(msg);
}
```

#### After
```js
function print(msg = 'default msg') {
    console.log(msg);
}

print(); // default msg
print(0) // 0
```

-   Default parameter is only for `undefined`.
-   msg가 `undefined`인 경우에만 자동으로 할당된다.

## 7. template literals

### 1) `${boolean}`

```js
const boolean = true
const message = `hello ${boolean}`
console.log(message)
// 결과 : "hello true"
```

### 2) `${object}`

```js
const object = { a: "apple" }
const message = `hello ${object}`
console.log(message)
// 결과 : "hello [object Object]
```
### 3) `${expression}`: ternary operator
```js
const name = "chalie"
const gender = "male"
const message = `Hello ${gender === "male" ? "Mr." : "Mrs."}${name}, nice to meet you`
console.log(message)
// 결과 : "Hello Mr.chalie, nice to meet you"
```

---

## 1. Optional Chaining (ES11)

#### `?.`

- 접근하는 **객체의 프로퍼티**가 `null` 또는 `undefined`일 수 있는 `optional property`인 경우, if 문을 사용하지 않고 넘어가게 하는 체이닝 방법이다.
- **객체가 `null` 또는 `undefined`이면, `undefined`를 리턴**, 그렇지 않은 경우 데이터 값을 리턴한다.

```js
const person1 = {
    name: 'junha',
    job: {
        title: 'Engineer',
        manager: {
            name: 'Bob',
        },
    },
};

const person2 = {
    name: 'yunjung',
    job:{
      title:"Cook"
    },
    action: {
      yelling() {
        console.log("YAYYY!")
      }
    }
};

function print(person) {
    console.log(person.job?.manager?.name);
}

print(person1); // Bob
print(person2); // undefined
person2.action?.yelling() // YAYYY!
```

## 2. Nullish Coalescing Operator (ES11)

- `undefind`, `null` 데이터타입의 속성에 접근하면 오류가 발생한다.

#### `??` 연산자: `null`과 `undefined` 일 경우에만 작동한다.

- `A || B`는 A가 `falsy`한 값인 경우 B를 반환했다.
- `A ?? B`는 A가 **`null`, `undefined`인 경우에만** B를 반환한다.
- `Nullish Coalescing Operator`는 `null`, `undefined`를 제외한 `falsy` 값을 그대로 리턴하고 싶은 경우 사용한다.
- `falsy`: `false`로 반환하는 값: `''`, `0`, `-0`, `null`, `undefined`, `NaN`

```js
const obj = {
    0: false,     // false : false
    1: '',        // : 
    2: 0,         // 0: 0
    3: null,      // null : Nullish Coalescing
    4: undefined, // undefined : Nullish Coalescing
    5: NaN,       // NaN : NaN
};

for (let key in obj) {
    console.log(`${obj[key]}: ${obj[key] ?? 'Nullish Coalescing'}`);
}
```

-   `leftExpr() ?? rightExpr()` 형태이기 때문에, `const result = func1() ?? func2()`도 가능하다.

## Quiz

-   Remove duplicates `['a','a','b','b','c','d','e']` and return as an array.

```js
const arr = ['a', 'a', 'b', 'b', 'c', 'd', 'e'];
const answer = [...new Set(arr)];
console.log(answer);
```