# Array

### `[number, string, Object]` → `[number, number, number]`
-   자바스크립트의 배열의 요소는 다양한 데이터 타입을 넣는 것이 가능하다.
-   하지만 동일한 데이터 타입을 넣는 것을 권장한다.  **비슷한 성격**을 갖고 있는 데이터를 하나의 변수 안에서 관리하기 위해 만들어진 객체이기 때문이다.

## 1. Looping over an array

```js
const fruits = ['🍒', '🥭', '🍍'];

for (let i = 0; i < fruits.length; i++) {
    console.log(fruits[i]);
}

for (fruit of fruits) {
    console.log(fruit);
}

fruits.forEach((fruit) => console.log(fruit));
```

### `forEach`는 반복도중 멈출 방법이 throw 밖에 없다!

- `foreach`는 각각의 요소에 대해 한번씩 실행한다는 의미가 강한 메서드다.
- 그러므로 중간에 looping을 멈추기 위해선, `for`반복문을 쓰거나 아래의 메서드를 사용해야한다.
- `every()`,` some()`, `find()`, `findIndex()`는 배열 요소를 판별 함수에 전달하고, 그 결과의 참/거짓 여부에 따라 반복의 종료 여부를 결정한다.

## 2. `push`, `pop`, `unshift`, `shift` 메서드

```js
// 배열 맨 뒤에
fruits.push('🥝');    // 데이터 삽입
fruits.pop();         // 데이터 제거

// 배열 맨 앞에 
fruits.unshift('🥝')  // 데이터 삽입
fruits.shift()        // 데이터 제거
```

-   `unshift`, `shift`는 배열의 전체 요소가 움직이기 때문에 `pop`, `push`보다 **느리다**.

## 3. `splice`

- `splice(*index, ?count, ?insertElement)`: 원본 변형

```js
const array1 = [0, 1, 2, 3, 4, 5];
array1.splice(1); // [0]
array1.splice(1, 1); // [0, 2, 3, 4, 5]
array1.splice(1, 1, 7); // [0, 7, 2, 3, 4, 5]
```
- 두번째 인자를 생략하면, `array[index:]` 두번째 인자부터 끝까지 엘리먼트를 포함시킨다.
- 세번째 인자부터, 지운 인덱스에 엘리먼트를 추가할 수 있다.

### 활용
- `contents.splice(i,1)`
- 원본에서 i인덱스 하나만 지우기


## 4. `concat`

- 두 배열을 합친 **새로운 배열**을 반환한다.

```js
const array1 = [0, 1, 2, 3, 4, 5];
const array2 = ['a', 'b', 'c'];

const array3 = array1.concat(array2);
console.log(array3); // [0, 1, 2, 3, 4, 5, 'a', 'b', 'c']
```

## 5. `indexof`, `includes`, `lastIndexof`

- 다음 메서드들은 Search에 관한 메서드이다.

```js
const tools = ['a', 'b', 'c', 'd', 'e', 'a'];

// indexOf: return the index of value
console.log(tools.indexOf('b')); // 1
console.log(tools.indexOf('z')); // -1

// includes: return true of false
console.log(tools.includes('a')); // true
console.log(tools.includes('y')); // false

// lastIndexOf
console.log(tools.indexof('a')); // 0
console.log(tools.lastIndexof('a')); // 5
```

## 6. `sort()`

```js
const arr = [1,2,3,4,9,11,12,13,5,6,7,8,14,10];
arr.sort() // [1, 10, 11, 12, 13, 14, 2, 3, 4, 5, 6, 7, 8, 9]
```
- 복사본이 만들어지지 않고, **원본 배열**이 정렬된다.
- `sort()`는 아스키 코드 기준으로 정렬이 되어, 정상적으로 정렬되지 않는다.
- `arr.sort([compareFunction])` : 매개변수로 비교 함수를 넣어,  오름차순으로 정렬할 수 있다.

```js
function compareNumbers(a, b) {
  return a - b;
}
```
- return 값이 음수이면 첫번째 인자가 먼저 출력된다. 

```js
arr.sort(compareNumbers) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```

## 7. `join()`

- `Array.prototye.join(separator?: string): string`
- 배열의 모든 요소들을 연결한 **하나의 문자열을 반환**한다.
- `separator`: 배열의 요소를 **구분**할 문자열
- `arr.length=0` 이면, **빈 문자열**을 반환한다.


```js
var arr = ['h','u','n','g','r','y']

arr.join()     // h,u,n,g,r,y
arr.join("")   // hungry
```


## 8. `slice()`

- `arr.slice([begin[, end]])`
- `[begin, end-1]`까지 얕은 복사를 통해 **새로운 배열**로 반환한다.
-  원본 배열은 바뀌지 않는다.
-  매개변수를 아무것도 넘기지 않으면, 원본 배열의 **얕은 복사본**을 반환한다. 

```js
const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];

console.log(animals.slice(2));
// slice(2) == slice(2,end) 
// ["camel", "duck", "elephant"]

console.log(animals.slice(2, 4));
// ["camel", "duck"]

console.log(animals.slice(1, 5));
// ["bison", "camel", "duck", "elephant"]

console.log(animals.slice(-2));
// slice(-2) == slice(-2, end) 
// ["duck", "elephant"]

console.log(animals.slice(2, -1));
// ["camel", "duck"]

console.log(animals.slice());
// ["ant", "bison", "camel", "duck", "elephant"]
```

## 9. `map()`

### 1) map 메서드 구조

```js
Array.prototype.map(callback[, thisArg])
callback: function(currentValue, index, array)
```

### 2) 작동 구현

```js
  function mapElements(func) {
    let newArray = [];

    for(let i =0 ; i<array.length;i++){
        newArray.push(func(array[i]))
    }
    return newArray;
  }
```

### 3) `python` 코드와 혼동 주의

- `python`은 `index`를 중시하는 언어이기 때문에 `index`가 먼저 등장한다.

```py
for index, item in enumerate(array)
```

```js
array.map((item,index)=>{...})
```



## 10. `filter()`

- `arr.filter(callback(element[, index[, array]])[, thisArg])`
- `callback`: 각 요소를 시험할 함수
-  `true`를 반환하면 요소를 유지하고, `false`를 반환하면 버린다.

```js
const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction'];

const result = words.filter(word => word.length > 6);

console.log(result);
// expected output: Array ["exuberant", "destruction"]
```

```js
  function filterElements(func) {
    let newArray = [];

    for(let i =0;i<array.length;i++){
        if(func(array[i])){
            newArray.push(array[i])
        }
    }
    return newArray;
  }
}
```

## 11. `Array.prototype.reduce()`

-  배열의 정보를 하나의 값(acc)으로 줄여주는 목적
- `arr.reduce(callback[, initialValue])`
  - `initialValue`: 배열의 **첫 번째 요소**(default)
  - 빈 배열에서 초기값 없이 `reduce`를 호출하면 `undefined`오류 발생
- `callback(accumulator, currentValue, ?currentIndex, ?array)`
- `return`: `reducer`에서 마지막으로 리턴한 값


```js
const arr = [1, 2, 3, 4];
const reducer = (acc, cur) => acc + cur;

arr.reduce(reducer, 0);
// expected output: 0 + 1 + 2 + 3 + 4 = 10
```

####  `initValue`를 설정하지 않으면, acc는 배열의 첫번째 요소가 되므로, 0을 넣어 합산 값을 초기화해야한다.
```js
data = [{...}, {...}, {...}]

data.reduce((acc,cur)=> acc + cur.price * cur.num)
// '[object Object]920015300' ❌

data.reduce((acc,cur)=> acc + cur.price * cur.num, 0)
// 120000 ✅
```

#### Promise 코드 활용 예시

- 콜백이 실행 된 뒤 또다시 같은 콜백에 무언가를 전달할 수 있는 능력을 활용
- 초기값 `Promise.resolve()`은 이행된 `Promise`를 반환한다.
- 이는 `then`을 가질 수 있는 값이기 때문에 바로 동기 호출이 가능하다.
- 이런 이유로 모든 배열을 순회하는 `reduce`함수가 호출된 콜백 함수를 기다리면서 진행할 수 있고 **동기적으로 값을 처리하게 된다.**


```js
// 프로미스를 동기적으로 실행하고 싶을 때
const iterable = [fn1, fn2, fn3] // asynchronous functions that return a promise

iterable.reduce((p, fn) => p.then(fn), Promise.resolve())

//  [fn1, fn2, fn3]
//  promise.then(fn1).then(fn2).then(fn3)
```

```js
// 배열에 들어있는 값들을 동기적으로 프로미스를 통해 실행하고 싶을 때
const promiseFactory = (time) => {
  return new Promise((resolve, reject) => {
    console.log(time); 
    setTimeout(resolve, time);
  });
};

[1000, 2000, 3000, 4000].reduce((acc, cur) => {
  return acc.then(() => promiseFactory(cur));
}, Promise.resolve());
// 바로 1000
// 1초 후 2000
// 2초 후 3000
// 3초 후 4000
```


## 12. Array.prototype.entries()

- 배열의 각 인덱스에 대한 키/값 쌍을 가지는 새로운 **Array Iterator 객체**를 반환한다.

```js
var a = ['a', 'b', 'c'];
var iterator = a.entries();

for (let e of iterator) {
  console.log(e);
}

// [0, 'a']
// [1, 'b']
// [2, 'c']

console.log(iterator) // Array Iterator {next:function}
```

## 13. Array.prototype.find()

- 주어진 판별 함수를 만족하는 **첫 번째 요소의 값**을 반환한다.
- 그런 요소가 없다면 `undefined`를 반환한다.

```js
const array1 = [5, 12, 8, 130, 44];
const found = array1.find(element => element > 10);

console.log(found)
// 12
```

## Array.prototype.some()

- 특정 조건을 만족하는 요소가 **존재여부 파악**의 목적으로 사용
- `boolean` 반환
- 빈 배열이면 `false` 반환

```js
const array = [1, 2, 3, 4, 5];

// checks whether an element is even
const even = (element) => element % 2 === 0;

console.log(array.some(even));
// expected output: true
```

## Array.prototype.from()

- `Array.from(arrayLike[, mapFn[, thisArg]])`
- `유사 배열 객체`, `Iterable object`를 얕게 복사해 새로운 `Array` 객체 반환
- `String` 객체는 `length` 프로퍼티를 소유하고 있으므로 `유사 배열 객체`이다.

```js
const string = 'hello world';

Array.from(string);
// ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
```




## examples

<details>
  <summary>알파벳 카운터(메소드 체이닝)</summary>

```js
const AlphabetCounter = {
  sentence: '',
  alphabetMap: {},

  setSentence: function (sentence) {
    this.sentence = sentence;
    return this;
  },

  buildAlphabetMap: function () {
    this.alphabetMap = this.sentence
      .trim()
      .toLowerCase()
      .split('')
      .filter((c) => c >= 'a' && c <= 'z')
      .reduce((map, char) => {
        if (!map[char]) map[char] = 0;
        map[char]++;
        return map;
      }, {});
    return this;
  },

  buildResult: function () {
    const resultString = Object.entries(this.alphabetMap)
      .reduce((acc, [alphabet, freq]) => `${acc} [${alphabet}: ${freq}]`, '')
      .trim();
    return `결과는 : ${resultString} 입니다.`;
  },
};

export default AlphabetCounter;
```
</details>