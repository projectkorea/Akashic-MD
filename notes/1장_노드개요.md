# 01. 노드 개요

## 1. DOM은 JavaScript `Node` 객체의 계층화된 트리다.

-   HTML 문서를 작성할 때 HTML 콘텐츠를 다른 HTML 콘텐츠 내에 캡슐화하게 된다.
-   이를 통해 트리로 표현 가능한 계층 구조가 만들어진다.
-   브라우저는 HTML코드를 해석해서 트리 형태로 구조화된 노드들을 가지고 있는 문서(DOM)을 생성한다.
-   HTML문서가 브라우저에 의해 해석되어, 실제 문서를 나타내는 노드 객체들의 트리 구조로 변환된다.
-   **DOM의 목적은 Javascript를 사용해서 문서에 대한 스크립트 작성을 위한 프로그래밍 인터페이스를 제공하는 것이다.**
![](https://user-images.githubusercontent.com/76730867/149727521-804e2076-46ef-4d00-8f87-00ecbb9796b1.png)

- `Node` 객체는 `DOM`에서 가장 최상위에 있는 객체다.
- 모든 `DOM` 객체는 `Node` 객체를 상속 받는다.

## 2. 노드 객체 유형(nodeType)

- HTML 문서를 다룰 때 마주치게 되는 일반적인 노드 유형이다.

```html
<!DOCTYPE html>
<html lang="en">
    <body>
        <script>
            console.log(Node.ELEMENT_NODE)
            // element 노드의 숫자 코드 값인 1이 출력됨
            for (var key in Node) {
                console.log(key, Node[key]);
            }
        </script>
    </body>
</html>
```
- 모두 대문자이며 `_`로 단어를 구분한다.

|숫자코드|nodeType|인터페이스/생성자|
|:--:|:--:|:--:|
|1|`ELEMENT_NODE`|`HTML*ELEMENT`, `HTMLBodyElement`, `<body>`, `<a>`, `<p>`, `<script>`, `<style>`, `<html>`, `<h1>`|
|2|`ATTRIBUTE_NODE`|`class = "funcEdges"`|
|3|`TEXT_NODE`| `html` 문서 내의 텍스트 문자|
|9|`DOCUMENT_NODE`|`window.document`|
|10|`DOCUMENT_TYPE_NODE`| `<!DOCTYPE HTML>`|
|11|`DOCUMENT_FRAGMENT_NODE`|`document.createDocumentFragment()`|

## 3. Node 객체로 부터 상속받은 하위 노드 객체

- DOM 트리의 각 노드 객체는 `Node`로 부터 속성과 메서드를 상속받는다.
- `Node`는 Javascript 생성자 함수이기 때문에 다른 객체들 처럼 `Object.prototye`로부터 상속받는다.
- `Object` < `Node` < `Document`  < `HTMLDocument`

## 4. 노드를 다루기 위한 속성 및 메서드

- `Node`인터페이스에서 제공되는 속성 및 메서드 외에, `document`, `HTMLElement`, `HTML*Element` 인터페이스와 같은 하위 노드 인터페이스에서도 다양한 속성 및 메서드가 존재한다.

#### Node.property
- `Node.childNodes`
- `Node.firstChild`
- `Node.lastChild`
- `Node.nextSibling`
- `Node.nodeName`
- `Node.nodeType`
- `Node.nodeValue`
- `Node.parentNode`
- `Node.previousSibling`

#### Node.method()
- `Node.appendChild()`
- `Node.cloneNode()`
- `Node.compareDocumentPosition()`
- `Node.contains()`
- `Node.hasChildNodes()`
- `Node.insertBefore()`
- `Node.isEqualNode()`
- `Node.removeChild()`
- `Node.replaceChild()`

#### Document.method()
- `document.createElement`
- `document.createTextNode`

#### HTML*Element.property
- `innerHTML`
- `outerHTML`
- `textContent`
- `innerText`
- `outerText`
- `firstElementChild`
- `lastElementChild`
- `nextElemmentChild`
- `previousElementChild`
- `children`

#### HTMLElement.method()
- `insertAdjacentHTML()`

## 5. 노드의 유형과 이름 식별

- 모든 노드는 `Node`로 부터 상속받는 `nodeType` `nodeName` 속성을 가진다.

```js
document.querySelector('a').nodeType === Node.ELEMENT_NODE
// true ,<a>는 Element노드이다.
```

## 6. 노드 값 가져오기
- `nodeValue` 속성은 대부분 노드 유형에서는 `null`값을 가져온다.
- 이 속성의 용도는 `Text`와 `Comment`노드에서 실제 텍스트 문자열을 추출하는데 초점을 맞추고 있다.

```html
<a href="#">Hi</a>
```

```js
document.doctype.nodeValue // null
document.querySelector('a').nodeValue // null

document.querySelector('a').firstChild.nodeValue // Hi
```

## 7,8. Element, Text 노드 생성하기

- 브라우저는 HTML문서를 초기 로딩할 때 노드를 생성을 처리한다.
- 하지만 `DOM API`를 이용하면 HTML 로딩 이후에도 노드를 생성할 수 있다.

#### 1) 메서드로 만들기
#### `createElement()`, `createTextNode()`, `createAttribute()`, `createComment()`

```js
document.createElement('div') // <div></div>
document.createTextNode('Hi') // "HI"
```

#### 2) 문자열로 만들기
#### `innerHTML`, `outerHTML`, `textContent`, `inserAdjacentHTML()`

```html
<div id="A"></div>
<div id="B"></div>
<span id="C"></span>
<div id="D"></div>
<div id="E"></div>
```

```js
document.getElementByID('A').innerHTML = '<strong>Hi</strong>'
document.getElementByID('B').outerHTML = '<div id="B" class="new">Da-ran!</div>'
document.getElementByID('C').textContent = 'dude'
document.getElementByID('D').innerText = 'Keep It!'
document.getElementByID('E').outerText = 'real!'
```
- `outer`속성은 선택한 요소에 마크업을 새로 쓴다.
```html
<div id="A"><strong>Hi</strong></div>
<div id="B" class="new">Da-ran!</div>
<span id="C">dude</span>
<div id="D">Keep It!</div> real!
```

- `innerHTML`은 문자열 내에서 발견된 HTML요소를 **실제 DOM노드**로 변환하는 반면, `textContent`는 **텍스트 노드**로만 생성한다.
- `innerHTML`은 무겁고 비싼 대가를 치르는 **HTML파서**를 호출하는 반면, 텍스트 노드는 간단하게 처리되므로, `innerHTML` 계열의 사용을 삼가야한다.
- `textContent`는 `<script>`, `<style>`을 비롯한 모든 요소의 내용을 가져올 수 있지만, `innertext`는 스타일에 대해서 알고 있지만 `textContent`와 달리 숨겨진 요소들의 텍스트는 반환하지 않는다. 
- `document.write()`메서드 역시 DOM에 노드를 생성해서 추가할 수 있다. `write()`으로 전달된 값은 페이지가 로딩 및 해석되는 동안 페이지에 출력되기 때문에 로딩된 **HTML문서가 해석 되는것을 지연/차단시키게 된다.**

##### `insertAdjacentHTML()`
- Element 노드에서만 작동한다. 
- 시작 태그의 앞, 뒤, 종료 태그의 앞, 뒤 태그에 노드를 삽입할 수 있다.

```html
<i id="elm"></i>
```

```js
var elm = document.getElementById('elm')

dle.insertAdjacentHTML('beforebegin','<div>')
dle.insertAdjacentHTML('afterbegin','<span>dude-</span>')
dle.insertAdjacentHTML('beforeend','<span>-are</span>')
dle.insertAdjacentHTML('afterend','</div>')
```

```html
<div><span>dude-</span><i id="elm"></i><span>-are</span></div>
```

- `beforebegin`, `afterend` 옵션은 노드가 DOM 트리 내에 존재하고 부모 요소를 가 가진 경우에만 동작한다.

## 9. DOM 트리를 Javascript 문자열로 추출하기

- DOM에 노드를 생성하고 추가하는 데 사용하는 속성(`innerHTML`, `outerHTML`, `textContent`)들이 Javascript 문자열로도 추출할 수 있다.

```js
console.log(document.getElementByID('A').innerHTML);
// <i>Hi</i>

console.log(document.getElementByID('A').innerText);
// Dude!

console.log(document.getElementByID('A').textContent);
// Dude!
```

## 10. `appendChild()`, `insertBefore()`를 사용하여 노드 객체를 DOM에 추가하기

- 두 메서드는 Javascript `노드 객체`를 DOM 트리에 삽입하게 한다.
- `appendChild()` 메서드는 호출된 노드의 **자식 노드 끝에 삽입**한다.

```html
<body>
  <p>Hi</p>
</body>
```

```js
var elementNode = document.createElement('strong');
var textNode = document.createTextNode(' Dude');

document.querySelector('p').appendChild(elementNode)
document.querySelector('strong').appendChild(textNode)

console.log(document.body.innerHTML)
<p>Hi<strong> Dude</strong></p>
```

- `insertBefore(삽입될노드, 해당노드)` 메서드는 **삽입 위치를 조정**할 때 사용한다.
- `해당노드` 인자를 생략하면 `appendChild()`처럼 작동한다.

```html
<ul>
  <li>2</li>
  <li>3</li>
</ul>
```

```js
var text1 = document.createTextNode('1')
var li = document.createElement('li')
li.appendChild(text1)

var ul = document.querySelector('ul')
ul.insertBefore(li,ul,firstChild)

//  <ul>
//    <li>1</li>
//    <li>2</li>
//    <li>3</li>
//  </ul>
```

## 11. `removeChild()`, `replaceChild()`를 사용하여 노드를 제거하거나 바꾸기

- 삭제하고자 하는 노드를 선택한 후 **부모 노드에 대한 접근**을 얻기 위해 `parentNode` 속성을 이용한다.

```js
divA.parentNode.removeChild(divA)
divA.parentNode.replaveChild(newSpan,divA)
```

- `removeChild()`, `replaceChild()`은 각각 제거된 노드를 반환하거나 노드를 교체하여 해당 노드가 현재 문서의 범위를 벗어나게 만드는 것이다.
- 해당 노드에 대한 메모리상의 참조는 여전히 가지게 된다.
- 제거하거나 바꾸는 대상에 따라 `innerHTML`, `outerHTML`, `textContent` 속성에 빈 문자열을 주는 것이 쉽고 빠를 수 있지만, 브라우저 메모리 누수가 발생할 수 있다는 점을 명심하자.

## 12. `cloneNode()`를 사용해 노드 복제하기

- 단일 노드, 모든 자식 노드를 복제할 수 있다.
- 노드와 그 자식 노드 모두 복제하려면, `cloneNode(true)`를 사용한다.

```html
<ul>
  <li>Hi</li>
  <li>There!</li>
</ul>
```

```js
var cloneUl = document.querySelector('ul').cloneNode();
cloneUl.innerHTML // ul만 복제되었기 때문에 빈 문자열이 출력
cloneUl // <ul></ul>

var cloneUl = document.querySelector('ul').cloneNode(true);
cloneUl.innerHTML // <li>Hi</li><li>There!</li>
cloneUl //
```

- Element 노드를 복제할 때, 모든 특성 및 값도 복제된다. `addeventListener`, `node.onclik`으로 추가된 것은 복제되지 않는다.
- `cloneNode(true)`를 통해 NodeList가 반환될 것 같지만, 그렇지 않고 자식을 품은 Element가 반환된다.

## 13. 노드 컬렉션에 대한 이해

- `NodeList`, `HTMLCollection`: 트리에서 노드 그룹을 선택하거나, 사전에 정의된 노드 집합에 접근할 때 사용한다. 
- 배열과 유사한 이 객체 컬랙션들은 다음과 같은 특징을 갖는다
  1. 컬렉션은 라이브 상태 혹은 정적일 수 있다. 컬랙션 내에 포함된 노드들이 현재 문서 또는 현재 문서에 대한 스냅샵의 일부라는 것을 의미한다.
  2. 노드는 트리 순서에 따라 컬랙션 내에서 정렬된다. 이 순서는 트리 루트로 부터 분기점까지의 선형 경로와 일치한다.
  3. 컬렉션은 리스트 내의 요소 개수를 나타내는 length 속성을 가진다.

## 14. 직계 자식 노드 전부에 대한 리스트/컬렉션 얻기

- `childNodes` 속성을 사용하면 직계 자식 노드에 대해 **배열 형태의 리스트(NodeList)**가 나온다.

```html
<ul>
  <li>hi</li>
  <li>money</li>
</ul>
```

```js
var ulElementChildNodes = document.querySelector('ul').childNodes;
ulElementChildNodes 
// NodeList(5) [text, li, text, li, text]
// 줄바꿈도 text노드로 인식되어 ul의 자식으로 들어갔다.
```
- `childNodes`에서 반환되는 NodeList는 **직계 자식**만을 가진다.
- `childNodes`는 Element노드 뿐만 아니라 Text, Comment 노드도 포함한다.
- NodeList는 루프를 돌 수 있는 배열 형태이기 때문에 내장 메서드인 `forEach`를 호출할 수도 있다.

## 15. NodeList, HTMLCollection을 JavaScript 배열로 변환

- `NodeList`, `HTMLCollection`을 `Array`로 변환하면 2가지 이점이 생긴다.
  1. `NodeList`, `HTMLCollection`는 라이브 리스트인데 비해, 현재DOM에 국한되지 않은 리스트 스냅샷을 만들 수 있다.
  2. `Array`객체가 제공하는 메서드들 접근할 수 있다.
- `Array.prototype.slice.call()`을 통해 배열로 변환한다.
```js
Array.isArray(document.querySelectorAll('a')) // false
Array.isArray(Array.prototype.slice.call(document.querySelectorAll('a'))) // true
```

## 16. DOM 내의 노드 탐색

- 현재 노드에 다음과 같은 속성을 이용하면 다른 노드에 대한 참조를 얻을 수 있다.

- `parentNode`, `firstChild`, `lastChild`, `nextSibling`, `previousSibling`

```html
<body>
  <ul><!-- comment -->
  <li id="A"></li>
  <li id="B"></li>
  <!-- comment -->
  </ul>
</body>
```

```js
var ul = document.querySelector("ul")

ul.parentNode.nodeName // body
ul.firstChild.nodeName // comment
ul.lastChild.nodeName // text (줄바꿈있음)

ul.querySelector('#A').nextSibling.nodeName // text
ul.quertSelctor('#B').previousSibling.nodeName // text
```

- 다음 속성을 이용하면 text와 comment 노드를 무시하고 DOM을 탐색할 수 있다.

- `firstElementChild`, `lastElementChild`, `nextElementSibling`, `previousElementSibling`, `children`, `parentElement`

```js
var ul = document.querySelector("ul")

ul.firstElementChild.nodeName // li
ul.lastElementChild.nodeName // li

ul.querySelector('#A').nextElementSibling.nodeName // li
ul.quertSelctor('#B').previousElementSibling.nodeName // li

// ul의 자식 노드 중 element만 가져오기
ul.children // HTMLCollection, 모든 자식 노드는 text노드를 가짐

// 첫번째 li의 부모 element 가져오기
ul.firstElementChild.parentElement // ul 출력
```

## 17. `contains()`와 `compareDocumentPosition()`으로 DOM트리 내의 Node위치 확인하기

- 노드의 `contatins()` 메서드를 사용하면 특정 노드가 다른 노드 내에 포함되어 있는지를 알 수 있다.

```js
document.querySelector('html').contains(document.querySelector('body')) // true

//<body>가 <html> 내에 있는지를 확인하는 코드
```

- 노드의 `compareDocumentPosition()` 메서드는 DOM 트리 내에서 주변 노드와 연관된 노드 위치에 대해 보다 확실한 정보를 얻고 싶을 경우 사용한다.

|compareDocumentPosition() 반환코드|숫자코드정보|
|:--:|:--:|
|0|동일한 Element이다.|
|1|DOCUMENT_POSITION_DISCONNECTED <br> 선택된 노드와 전달된 노드가 동일한 문서에 존재하지 않음.|
|2|DOCUMENT_POSITION_PRECEDING <br> 전달된 노드가 선택된 노드 앞에 있음.|
|4|DOCUMENT_POSITION_FOLLOWING <br> 전달된 노드가 선택된 노드 뒤에 있음.|
|8|DOCUMENT_POSITION_CONTAINS <br> 전달된 노드가 선택된 노드의 조상임.|
|16,10|DOCUMENT_POSITION_CONTAINED_BY <br> 전달된 노드가 선택된 노드의 자손임.|

- 숫자코드는 특정 노드가 다른 노드와 하나 이상의 관계를 가질 수 있다.
- 노드가 포함 관계(16)이자, 앞에 있는 경우(4)는 16+4=20을 반환한다.

## 18. 두 노드가 동일한지 판단하기

- 두 노드가 동일한 조건은 다음과 같다.
   - 두 노드가 동일한 형식이다.
   - nodeName, localName, namespaceURI, prefix, nodeValue 문자열 특성이 동일하다. 즉, 둘다 null이거나, 동일한 길이와 문자를 가져야한다.
   - NameNodeMaps 특성이 동일하다. 둘 다 null이거나 길이가 동일해야 하며, 하나의 맵 내에 존재하는 각 노드들과 다른 맵에 존재하는 노드가 동일해야 하되 인덱스가 동일할 필요는 없다.
   - childNodes NodeLists가 동일하다. 둘 다 Null이거나, 동일한 길이를 가지고 같은 인덱스의 노드가 동일해야 한다. 정규화가 동일성에 영향을 미칠 수 있으므로 비교 수행 전에 노드를 정규화해야한다.

- DOM 내의 노드에 대해 `isEqualNode()` 메서드를 호출하면, 매개변수로 전달하는 노드와 동일한지 물어본다. 

```html
<input type="text">
<input type="text">

<textarea>foo</textarea>
<textarea>bar</textarea>
```

```js
var input = document.querySelectorAll('input');
input[0].isEqualNode(input[1]) //true

var textarea = document.querySelectorAll('textarea');
textarea[0].isEqualNode(textarea[1]) // false
```
- 두 노드가 완전히 동일한지가 아니라, 두 노드 참조가 동일한 노드를 참조하고 있는지 알고 싶다면 `===` 연산자를 사용하여 간단하게 확인해볼 수 있다.