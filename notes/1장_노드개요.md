# 01. 노드 개요

## 1. DOM은 JavaScript `Node` 객체의 계층화된 트리다.

-   HTML 문서를 작성할 때 HTML 콘텐츠를 다른 HTML 콘텐츠 내에 캡슐화하게 된다.
-   이를 통해 트리로 표현 가능한 계층 구조가 만들어진다.
-   브라우저는 HTML코드를 해석해서 트리 형태로 구조화된 노드들  을 가지고 있는 문서(DOM)을 생성한다.
-   HTML문서가 브라우저에 의해 해석되어, 실제 문서를 나타내는 노드 객체들의 트리 구조로 변환된다.
-   **DOM의 목적은 Javascript를 사용해서 문서에 대한 스크립트 작성을 위한 프로그래밍 인터페이스를 제공하는 것이다.**
![](https://user-images.githubusercontent.com/76730867/149727521-804e2076-46ef-4d00-8f87-00ecbb9796b1.png)

- `Node` 객체는 `DOM`에서 가장 최상위에 있는 객체다.
- 모든 `DOM` 객체는 `Node` 객체를 상속 받는다.

## 2. 노드 객체 유형(nodeType)

- HTML 문서를 다룰 때 마주치게 되는 일반적인 노드 유형이다.

```html
<!DOCTYPE html>
<html lang="en">
    <body>
        <script>
            console.log(Node.ELEMENT_NODE)
            // element 노드의 숫자 코드 값인 1이 출력됨
            for (var key in Node) {
                console.log(key, Node[key]);
            }
        </script>
    </body>
</html>
```
- 모두 대문자이며 `_`로 단어를 구분한다.

|숫자코드|nodeType|인터페이스/생성자|설명|
|:--:|:--:|:--:|:--:|
|1|`ELEMENT_NODE`|`HTML*ELEMENT`, `HTMLBodyElement`, `<body>`, `<a>`, `<p>`, `<script>`, `<style>`, `<html>`, `<h1>`|속성 노드를 가질 수 있는 유일한 노드|
|2|`ATTRIBUTE_NODE`|`class = "funcEdges"`|모든 HTML요소의 속성은 속성 노드이며 엘리먼트 노드에 대한 정보를 가진다. 해당 요소 노드의 자식노드에는 포함되지 않는다.|
|3|`TEXT_NODE`| `html` 문서 내의 텍스트 문자||
|9|`DOCUMENT_NODE`|`window.document`, `HTMLDocument()`|HTML 문서 전체를 나타내는 노드|
|10|`DOCUMENT_TYPE_NODE`| `<!DOCTYPE HTML>`, `DocumentType()`||
|11|`DOCUMENT_FRAGMENT_NODE`|`document.createDocumentFragment()`||

## 3. Node 객체로 부터 상속받은 하위 노드 객체

- DOM 트리의 각 노드 객체는 `Node`로 부터 속성과 메서드를 상속받는다.
- `Node`는 Javascript 생성자 함수이기 때문에 다른 객체들 처럼 `Object.prototye`로부터 상속받는다.
- `Object` < `Node` < `Document`  < `HTMLDocument`

## 4. 노드를 다루기 위한 속성 및 메서드

- `Node`인터페이스에서 제공되는 속성 및 메서드 외에, `document`, `HTMLElement`, `HTML*Element` 인터페이스와 같은 하위 노드 인터페이스에서도 다양한 속성 및 메서드가 존재한다.

#### Node.property
- `Node.childNodes`
- `Node.firstChild`
- `Node.lastChild`
- `Node.nextSibling`
- `Node.nodeName`
- `Node.nodeType`
- `Node.nodeValue`
- `Node.parentNode`
- `Node.previousSibling`

#### Node.method()
- `Node.appendChild()`
- `Node.cloneNode()`
- `Node.compareDocumentPosition()`
- `Node.contains()`
- `Node.hasChildNodes()`
- `Node.insertBefore()`
- `Node.isEqualNode()`
- `Node.removeChild()`
- `Node.replaceChild()`

#### Document.method()
- `document.createElement`
- `document.createTextNode`

#### HTML*Element.property
- `innerHTML`
- `outerHTML`
- `textContent`
- `innerText`
- `outerText`
- `firstElementChild`
- `lastElementChild`
- `nextElemmentChild`
- `previousElementChild`
- `children`

#### HTMLElement.method()
- `insertAdjacentHTML()`

## 5. 노드의 유형과 이름 식별

- 모든 노드는 `Node`로 부터 상속받는 `nodeType` `nodeName` 속성을 가진다.

```js
document.querySelector('a').nodeType // 1 Node.ELEMENT_NODE
document.querySelector('a').nodeName // A
```

## 6. 노드 값 가져오기
- `nodeValue` 속성은 대부분 노드 유형에서는 `null`값을 가져온다.
- 이 속성의 용도는 `Text`와 `Comment`노드에서 실제 텍스트 문자열을 추출하는데 초점을 맞추고 있다.

```html
<a href="#">Hi</a>
```

```js
document.doctype.nodeValue // null
document.querySelector('a').nodeValue // null

document.querySelector('a').firstChild.nodeValue // Hi
```

## 7,8. Element, Text 노드 생성하기

- 브라우저는 HTML문서를 초기 로딩할 때 노드를 생성을 처리한다.
- 하지만 `DOM API`를 이용하면 HTML 로딩 이후에도 노드를 생성할 수 있다.

### 1) 메서드로 만들기
#### `createElement()`, `createTextNode()`, `createAttribute()`, `createComment()`

```js
document.createElement('div') // <div></div>
document.createTextNode('Hi') // "HI"
```

### 2) 문자열로 만들기
#### `innerHTML`, `outerHTML`, `textContent`, `inserAdjacentHTML()`

```html
<div id="A"></div>
<div id="B"></div>
<span id="C"></span>
<div id="D"></div>
<div id="E"></div>
```

```js
document.getElementByID('A').innerHTML = '<strong>Hi</strong>'
document.getElementByID('B').outerHTML = '<div id="B" class="new">Da-ran!</div>'
document.getElementByID('C').textContent = 'dude'
document.getElementByID('D').innerText = 'Keep It!'
document.getElementByID('E').outerText = 'real!'
```
- `outer`속성은 선택한 요소에 마크업을 새로 쓴다.
```html
<div id="A"><strong>Hi</strong></div>
<div id="B" class="new">Da-ran!</div>
<span id="C">dude</span>
<div id="D">Keep It!</div> real!
```
### 3) `innerHTML` vs `innerText` vs `textContent`

#### `innerHTML`

- `innerHTML`은 무겁고 비싼 대가를 치르는 **HTML파서**를 호출하기 때문에, 텍스트 노드만 생성하는 경우, `innerHTML` 계열의 사용을 삼가야한다.
- `innerHTML`은 문자열 내에서 발견된 HTML요소를 **실제 DOM노드**로 변환하는 반면, `textContent`는 **텍스트 노드**로만 생성한다.


#### `innerText` vs `textContent`

- `innerText`는 스타일에서 숨겨진 요소들의 텍스트는 반환하지 않는다. 
- `innerText`는 CSS의 영향을 받으므로 리플로우가 발생한다.
- `textContent`는 `<script>`, `<style>`을 비롯한 모든 요소의 내용을 가져올 수 있다.
- `innerText`는 비표준인 반면,`textContent`는 DOM 사양으로 구현되었다.
- `innerText`는 텍스트를 정규화해서 반환하는 반면, `textContent`는 문서 내에 있는 것을 마크업만 제거해서 그대로 반환하기 때문에 공백, 줄바꿈 개행문자도 포함된다.

```js
<span>Hello
  <span style="display: none;">World</span>
</span>

innerText // Hello
textContent // Hello World
```
- As a result, `innerText` is much more performance-heavy: it requires layout information to return the result.

- `innerText` is defined only for `HTMLElement` objects, while `textContent` is defined for all `Node` objects.

#### `document.write()`
- `document.write()`메서드 역시 DOM에 노드를 생성해서 추가할 수 있다. `write()`으로 전달된 값은 페이지가 로딩 및 해석되는 동안 페이지에 출력되기 때문에 로딩된 **HTML문서가 해석 되는것을 지연/차단시키게 된다.**

#### `insertAdjacentHTML()`
- Element 노드에서만 작동한다. 
- 시작 태그의 앞, 뒤, 종료 태그의 앞, 뒤 태그에 노드를 삽입할 수 있다.

```html
<i id="elm"></i>
```

```js
var elm = document.getElementById('elm')

dle.insertAdjacentHTML('beforebegin','<div>')
dle.insertAdjacentHTML('afterbegin','<span>dude-</span>')
dle.insertAdjacentHTML('beforeend','<span>-are</span>')
dle.insertAdjacentHTML('afterend','</div>')
```

```html
<div><span>dude-</span><i id="elm"></i><span>-are</span></div>
```

- `beforebegin`, `afterend` 옵션은 노드가 DOM 트리 내에 존재하고 부모 요소를 가 가진 경우에만 동작한다.

## 9. DOM 트리를 Javascript 문자열로 추출하기

- DOM에 노드를 생성하고 추가하는 데 사용하는 속성(`innerHTML`, `outerHTML`, `textContent`)들이 Javascript 문자열로도 추출할 수 있다.

```js
console.log(document.getElementByID('A').innerHTML);
// <i>Hi</i>

console.log(document.getElementByID('A').innerText);
// Dude!

console.log(document.getElementByID('A').textContent);
// Dude!
```

## 10. `appendChild()`, `insertBefore()`를 사용하여 노드 객체를 DOM에 추가하기

- 두 메서드는 Javascript `노드 객체`를 DOM 트리에 삽입하게 한다.
- `appendChild()` 메서드는 호출된 노드의 **자식 노드 끝에 삽입**한다.

```html
<body>
  <p>Hi</p>
</body>
```

```js
var elementNode = document.createElement('strong');
var textNode = document.createTextNode(' Dude');

document.querySelector('p').appendChild(elementNode)
document.querySelector('strong').appendChild(textNode)

console.log(document.body.innerHTML)
<p>Hi<strong> Dude</strong></p>
```

- `insertBefore(삽입될노드, 해당노드)` 메서드는 **삽입 위치를 조정**할 때 사용한다.
- `해당노드` 인자를 생략하면 `appendChild()`처럼 작동한다.

```html
<ul>
  <li>2</li>
  <li>3</li>
</ul>
```

```js
var text1 = document.createTextNode('1')
var li = document.createElement('li')
li.appendChild(text1)

var ul = document.querySelector('ul')
ul.insertBefore(li,ul,firstChild)

//  <ul>
//    <li>1</li>
//    <li>2</li>
//    <li>3</li>
//  </ul>
```

## 11. `removeChild()`, `replaceChild()`를 사용하여 노드를 제거하거나 바꾸기

- 위의 두 메서드는 해당 노드를 **반환**하며, `parentNode` 속성을 이용하여 **부모 노드에 대한 접근**을 얻어야한다.

```js
divA.parentNode.removeChild(divA)
divA.parentNode.replaveChild(newSpan,divA)
```

- `removeChild()`, `replaceChild()`은 해당 노드를 삭제하는 것이 아니라, **해당 돔트리와의 연결을 해제시켜 문서의 범위를 벗어나게 만들기만 한다.** 따라서 해당 노드에 대한 메모리상의 참조는 여전히 가지게 된다.
- 그리고 제거하거나 바꾸는 대상에 따라 `innerHTML`, `outerHTML`, `textContent` 속성에 빈 문자열을 주는 쉽고 빠른 방법도 있지만 실제로 노드를 메모리상에서 삭제하는 것이 아니기 때문에 브라우저 메모리 누수가 발생할 수 있다.

## 12. `cloneNode()`를 사용해 노드 복제하기

- 단일 노드, 모든 자식 노드를 복제할 수 있다.
- 노드와 그 자식 노드 모두 복제하려면, `cloneNode(true)`를 사용한다.

```html
<ul>
  <li>Hi</li>
  <li>There!</li>
</ul>
```

```js
var cloneUl = document.querySelector('ul').cloneNode();
cloneUl.innerHTML // ul만 복제되었기 때문에 빈 문자열이 출력
cloneUl // <ul></ul>

var cloneUl = document.querySelector('ul').cloneNode(true);
cloneUl.innerHTML // <li>Hi</li><li>There!</li>
cloneUl //
```

- Element 노드를 복제할 때, 모든 특성 및 값도 복제된다. `addeventListener`, `node.onclik`으로 추가된 것은 복제되지 않는다.
- `cloneNode(true)`를 통해 NodeList가 반환될 것 같지만, 그렇지 않고 자식을 품은 Element가 반환된다.

## 16. DOM 내의 노드 탐색

- 현재 노드에 다음과 같은 속성을 이용하면 다른 노드에 대한 참조를 얻을 수 있다.

- `parentNode`, `firstChild`, `lastChild`, `nextSibling`, `previousSibling`

```html
<body>
  <ul><!-- comment -->
  <li id="A"></li>
  <li id="B"></li>
  <!-- comment -->
  </ul>
</body>
```

```js
var ul = document.querySelector("ul")

ul.parentNode.nodeName // body
ul.firstChild.nodeName // comment
ul.lastChild.nodeName // text (줄바꿈있음)

ul.querySelector('#A').nextSibling.nodeName // text
ul.quertSelctor('#B').previousSibling.nodeName // text
```

- 다음 속성을 이용하면 text와 comment 노드를 무시하고 DOM을 탐색할 수 있다.

- `firstElementChild`, `lastElementChild`, `nextElementSibling`, `previousElementSibling`, `children`, `parentElement`

```js
var ul = document.querySelector("ul")

ul.firstElementChild.nodeName // li
ul.lastElementChild.nodeName // li

ul.querySelector('#A').nextElementSibling.nodeName // li
ul.quertSelctor('#B').previousElementSibling.nodeName // li

// ul의 자식 노드 중 element만 가져오기
ul.children // HTMLCollection, 모든 자식 노드는 text노드를 가짐

// 첫번째 li의 부모 element 가져오기
ul.firstElementChild.parentElement // ul 출력
```

## 17. `contains()`와 `compareDocumentPosition()`으로 DOM트리 내의 Node위치 확인하기

- 노드의 `contatins()` 메서드를 사용하면 특정 노드가 다른 노드 내에 포함되어 있는지를 알 수 있다.

```js
document.querySelector('html').contains(document.querySelector('body')) // true

//<body>가 <html> 내에 있는지를 확인하는 코드
```

- 노드의 `compareDocumentPosition()` 메서드는 DOM 트리 내에서 주변 노드와 연관된 노드 위치에 대해 보다 확실한 정보를 얻고 싶을 경우 사용한다.

|compareDocumentPosition() 반환코드|숫자코드정보|
|:--:|:--:|
|0|동일한 Element이다.|
|1|DOCUMENT_POSITION_DISCONNECTED <br> 선택된 노드와 전달된 노드가 동일한 문서에 존재하지 않음.|
|2|DOCUMENT_POSITION_PRECEDING <br> 전달된 노드가 선택된 노드 앞에 있음.|
|4|DOCUMENT_POSITION_FOLLOWING <br> 전달된 노드가 선택된 노드 뒤에 있음.|
|8|DOCUMENT_POSITION_CONTAINS <br> 전달된 노드가 선택된 노드의 조상임.|
|16,10|DOCUMENT_POSITION_CONTAINED_BY <br> 전달된 노드가 선택된 노드의 자손임.|

- 숫자코드는 특정 노드가 다른 노드와 하나 이상의 관계를 가질 수 있다.
- 노드가 포함 관계(16)이자, 앞에 있는 경우(4)는 16+4=20을 반환한다.

## 18. 두 노드가 동일한지 판단하기

- 두 노드가 동일한 조건은 다음과 같다.
   - 두 노드가 동일한 형식이다.
   - nodeName, localName, namespaceURI, prefix, nodeValue 문자열 특성이 동일하다. 즉, 둘다 null이거나, 동일한 길이와 문자를 가져야한다.
   - NameNodeMaps 특성이 동일하다. 둘 다 null이거나 길이가 동일해야 하며, 하나의 맵 내에 존재하는 각 노드들과 다른 맵에 존재하는 노드가 동일해야 하되 인덱스가 동일할 필요는 없다.
   - childNodes NodeLists가 동일하다. 둘 다 Null이거나, 동일한 길이를 가지고 같은 인덱스의 노드가 동일해야 한다. 정규화가 동일성에 영향을 미칠 수 있으므로 비교 수행 전에 노드를 정규화해야한다.

- DOM 내의 노드에 대해 `isEqualNode()` 메서드를 호출하면, 매개변수로 전달하는 노드와 동일한지 물어본다. 

```html
<input type="text">
<input type="text">

<textarea>foo</textarea>
<textarea>bar</textarea>
```

```js
var input = document.querySelectorAll('input');
input[0].isEqualNode(input[1]) //true

var textarea = document.querySelectorAll('textarea');
textarea[0].isEqualNode(textarea[1]) // false
```
- 두 노드가 완전히 동일한지가 아니라, 두 노드 참조가 동일한 노드를 참조하고 있는지 알고 싶다면 `===` 연산자를 사용하여 간단하게 확인해볼 수 있다.